#!/usr/bin/env node

require('colors');
var path = require('path');
var pkg = require(path.join(__dirname, '..', 'package.json'));
var config = require('../lib/config');
var cli = require('../lib/util/cli');
var commands = require('../lib/commands');
var updateNotifier = require('update-notifier');

// --------

var options;
var renderer;
var loglevel;
var command;
var notifier;
var levels = {
    'error': 5,
    'warn': 4,
    'action': 3,
    'info': 2,
    'debug': 1
};

process.title = 'bower';

// Handle print of version
options = cli.readOptions({
    version: { type: Boolean, shorthand: 'v' }
});

if (options.version) {
    process.stdout.write(pkg.version + '\n');
    process.exit();
}

// Set log level
if (config.silent) {
    loglevel = Infinity;
} else if (config.verbose) {
    loglevel = -Infinity;
} else if (config.quiet) {
    loglevel = levels.warn;
} else {
    loglevel = levels[config.loglevel] || levels.info;
}

// Get the renderer
renderer = cli.getRenderer(config);

// Check for newer version of Bower
notifier = updateNotifier({
    packageName: pkg.name,
    packageVersion: pkg.version
});

if (notifier.update && levels.info >= loglevel) {
    renderer.updateAvailable(notifier.update);
}

// Get the command to execute
// TODO: abbreviations
command = options.argv.remain && options.argv.remain.shift();
if (!commands[command]) {
    command = 'help';
}

// Execute the command
commands[command].line(process.argv)
.on('end', function (data) {
    if (config.silent) {
        return;
    }

    // Execute the specific render method for the command
    if (renderer[command]) {
        renderer[command](data);
    // Fallback to the generic end method
    } else {
        renderer.end(data);
    }
})
.on('error', function (err)  {
    if (levels.error >= loglevel) {
        renderer.error(err);
    }

    process.exit(1);
})
.on('notification', function (notification) {
    if (levels[notification.level] >= loglevel) {
        renderer.notification(notification);
    }
});
